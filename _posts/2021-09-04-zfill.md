---
layout: post
title: "Python의 zfill() 함수"
subtitle: "python의 builtin함수 zfill() 만들어보기"
author: "jay"
header-style: text
comments: true
tags:
  - Python
---

### 1. Python의 zfill() 함수는

{str 변수}.zfill(n)함수는 정수 n을 파라미터로 받아, string 변수를 n자리만큼의 길이로 만들며, **부족한 자릿수 만큼 앞에 0을 추가**하여 반환하는 **파이썬의 내장함수**이다. 

사용 예시를 보자.

```python
print("12345".zfill(3))
# 12345

print("12345".zfill(10))
# 0000012345

print("-12345".zfill(10))
# -000012345

print("+12345".zfill(10))
# +000012345
```

1. n이 문자열의 자릿수보다 작을 경우, 문자열을 그대로(원래 길이) 반환한다.
2. n이 문자열의 자릿수보다 클 경우, 앞에 부족한 만큼 0을 붙여 반환한다.
3. signed 변수로 선언하고 싶을 경우, 앞에 \- / +를 붙일 수 있다.

### 2. 유용성

이 함수를 어떤 경우에 사용할 수 있을까?

1. 숫자를 진수변환 할 때
2. global define 코드들의 자릿수를 통일시키고자 할 때
3. *기타 내 마음이 내킬 때*

![000009](\img\in-post\000009.png)

나같은 경우에는, 10진수 숫자를 2진수로 변환하고 연산처리하는 과정에서 쓰게되었다.

### 3. 구현해보기

**zfill() 함수는 파이썬의 str 클래스에 구현된 내장메서드로** string 변수.zfill(n)으로 간편하게 사용 가능하지만(메서드 체이닝 또한 가능), 앞에 숫자 0만 붙일 수 있다는 제한이 있다.

**그래서 직접 구현해봤다. 근데 이제 `filling` 파라미터를 곁들여서**

\* `filling` == *앞에 채울 character(문자열도 가능)*

```python
# == zfill()
def valueFill(strParam: str, filling: str, length: int) -> str:
    # 파라미터 길이 체크
    if len(strParam) >= length: return strParam

    # + / - 일 때 처리
    firstIdx = strParam[:1]
    if firstIdx == '-' or firstIdx == '+':
        return firstIdx + valueFill(strParam[1:], filling, length-1)
    
    # length 길이만큼 filling 채우기
    for i in range(length):
        if length > len(strParam):
            strParam = filling + strParam
        else:
            break
    
    return strParam
```

테스트를 해본다.

```python
print("12345".zfill(3))
# 12345
print("12345".zfill(10))
# 0000012345
print("-12345".zfill(10))
# -000012345
print("+12345".zfill(10))
# +000012345

print(valueFill("12345", "0", 3))
# 12345
print(valueFill("12345", "0", 10))
# 0000012345
print(valueFill("-12345", "0", 10))
# -000012345
print(valueFill("+12345", "0", 10))
# +000012345
```

똑같이 잘 나온다.

```python
print(valueFill("BTotheY", "얍", 10))
print(valueFill("BTotheY", "얍얍얍", 10))
print(valueFill("BTotheY", "얍", 40))

#얍얍얍BTotheY
#얍얍얍BTotheY
#얍얍얍얍얍얍얍얍얍얍얍얍얍얍얍얍얍얍얍얍얍얍얍얍얍얍얍얍얍얍얍얍얍BTotheY
```

문자열로도 적용이 된다.



더 확장성 있게 구현한 zfill() 함수였다.

---

### 알게 된 점

python의 slice에는 특이한 점이 있다.

배열, 또는 문자열의 존재하지 않는 인덱스에 접근하면 index out of range 에러가 나지만, sllice를 사용할 때는 에러가 발생하지 않고 `None`을 반환한다.

예를 들면,

```python
print('hello'[4:])	# 마지막(index ==4)인 'o' 반환
print('hello'[5])	# IndexError: string index out of range 발생
print('hello'[5:])	# 에러 X, none 반환
```

이는 **{변수}[idx]로 접근할 때에는 해당 자료형의 원소를 반환하지만, {변수}[idx:n]\(슬라이스)를 사용할 경우, 배열을 반환하기 때문**이라고 한다. 파이썬의 Slicing 내장함수에서, bounds-checked를 하지 않으며, 존재하지 않는 인덱스에 접근할 경우, 빈 배열값을 반환한다.

> 참고 글: <https://stackoverflow.com/questions/17250409/why-doesnt-python-throw-an-error-for-this>{:target="_blank"}
Slicing never raise error in python for out of bound indexes..

```python
>>> s =[1,2,3]
>>> s[-1000:1000]
[1, 2, 3]
```

From the [docs](http://docs.python.org/2/tutorial/introduction.html#strings) on string(applies to lists, tuples as well):

> Degenerate slice indices are handled gracefully: an index that is too large is replaced by the string size, an upper bound smaller than the lower bound returns an empty string.

[Docs](http://docs.python.org/2/library/stdtypes.html#sequence-types-str-unicode-list-tuple-bytearray-buffer-xrange)(lists):

> The slice of `s` from `i` to `j` is defined as the sequence of items with index `k` such that `i <= k < j`. If `i` or `j` is greater than `len(s)`, use `len(s)`. If `i` is omitted or `None`, use `0`. If `j` is omitted or `None`, use `len(s)`. If `i` is greater than or equal to `j`, the slice is empty.

Out-of-range negative slice indices are truncated, but don’t try this for single-element (non-slice) indices:

```python
>>> word = 'HelpA'
>>> word[-100:]
'HelpA'
```